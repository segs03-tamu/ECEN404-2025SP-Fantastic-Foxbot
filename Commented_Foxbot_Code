#include <stdio.h> //needed library 
#include "esp_log.h" //needed library
#include "driver/i2c.h" //needed library
#include <math.h> //needed library
#include "driver/gpio.h" //needed library
#include "driver/adc.h" //needed library
#include "driver/dac.h" //needed library
#include "freertos/FreeRTOS.h" //needed library
#include "freertos/task.h" //needed library
#include <string.h> //needed library
#include <unistd.h> //needed library

#include "driver/uart.h" //needed driver
#include "mavlink.h" //needed driver

#define SAMPLE_PERIOD_MS		200
#define I2C_SDA_IO              21  //baud rate
#define I2C_SCL_IO              22  //baud rate
#define I2C_FREQ_HZ             100000  //baud rate

#define TS1_GPIO                18                /*Raising Edge to boot chip*/


#define I2C_PORT_NUM			I2C_NUM_1        /*!< I2C port number for master dev */
#define I2C_TX_BUF_DISABLE  	0                /*!< I2C master do not need buffer */
#define I2C_RX_BUF_DISABLE  	0                /*!< I2C master do not need buffer */

// I2C common protocol defines
#define WRITE_BIT                          I2C_MASTER_WRITE /*!< I2C master write */
#define READ_BIT                           I2C_MASTER_READ  /*!< I2C master read */
#define ACK_CHECK_EN                       0x1              /*!< I2C master will check ack from slave*/
#define ACK_CHECK_DIS                      0x0              /*!< I2C master will not check ack from slave */
#define ACK_VAL                            0x0              /*!< I2C ack value */
#define NACK_VAL                           0x1              /*!< I2C nack value */

// BQ7692003 Registers
#define BQ7692003PWR_I2C_ADDR		0x08 //pin initialization

#define SYS_STAT        0x00 //pin initialization
#define SYS_CTRL1       0x04 //pin initialization
#define SYS_CTRL2       0x05 //pin initialization
#define PROTECT1        0x06 //pin initialization
#define PROTECT2        0x07 //pin initialization
#define PROTECT3        0x08 //pin initialization
#define VC1_HI          0x0C //pin initialization
#define VC1_LO          0x0D //pin initialization
#define VC2_HI          0x0E //pin initialization
#define VC2_LO          0x0F //pin initialization
#define VC3_HI          0x10 //pin initialization 
#define VC3_LO          0x11 //pin initialization
#define VC4_HI          0x12 //pin initialization
#define VC4_LO          0x13 //pin initialization
#define VC5_HI          0x14 //pin initialization
#define VC5_LO          0x15 //pin initialization

#define CC_CFG          0x0B //pin initialization

#define CELLBAL1        0x01 //pin initialization


#define UV_TRIP         0x0A //pin initialization


#define BAT_HI          0x2A //pin initialization
#define BAT_LO          0x2B //pin initialization


#define ADCGAIN1        0x50 //pin initialization
#define ADCOFFSET       0x51 //pin initialization
#define ADCGAIN2        0x59 //pin initialization


// Constants for the morse code bit
#define DAC_PIN DAC_CHANNEL_1   // GPIO25 (DAC1)
#define LED_PIN GPIO_NUM_2      // GPIO2 (Built-in LED on many ESP32 boards)
#define SINE_RESOLUTION 100     // Number of points in one sine wave cycle
#define ADC_MAX_VALUE 4095      // 12-bit ADC max value
#define VOLTAGE_MAX 3.3         // Maximum ADC input voltage

#define FREQUENCY 2000      // Maximum frequency (Hz)

// Morse code timing (in milliseconds)
/*
#define DOT_DURATION 100 //this is the dots for the morse
#define DASH_DURATION 300 //this is the dashes for the morse
#define PART_SPACE_DURATION 100 //spacing for the dots
#define LETTER_SPACE_DURATION 300 //spacing for the dashes
#define WORD_SPACE_DURATION 700 //spacing between each word
*/
#define DOT_DURATION 1000 //this is the dots for the morse
#define DASH_DURATION 3000 //this is the dashes for the morse
#define PART_SPACE_DURATION 1000 // spacing for the dots
#define LETTER_SPACE_DURATION 3000 //spacing for the dashes
#define WORD_SPACE_DURATION 7000 //spacing for the words


#define Trans GPIO_NUM_23 //turns the transistor on for PTT


#define Bit0 GPIO_NUM_36 //first bit of the decoder output 
#define Bit1 GPIO_NUM_39 //second bit of the decoder output
#define Bit2 GPIO_NUM_34 //third bit of the decoder output
#define Bit3 GPIO_NUM_35 //fourth bit of the decoder output

// Define the GPIO pins
#define NUM_PINS 4 //we are going to be redefining 4 IO pins
const gpio_num_t pins[NUM_PINS] = {GPIO_NUM_36, GPIO_NUM_39, GPIO_NUM_34, GPIO_NUM_35};  // Replace with your GPIO pin numbers



static const char *TAG = "i2c_restart"; //initializing the tag

// Function to read data from a slave device's register over I2C
static esp_err_t i2c_master_read_slave_reg(i2c_port_t i2c_num, uint8_t i2c_addr, uint8_t i2c_reg, uint8_t* data_rd, size_t size)
{
    if (size == 0) { //if request read size is 0
        return ESP_OK; //return immediately with success
    }
    i2c_cmd_handle_t cmd = i2c_cmd_link_create(); //create new I2C command link
    i2c_master_start(cmd); //generate start condition on I2C bus
    // first, send device address (indicating write) & register to be read
    i2c_master_write_byte(cmd, ( i2c_addr << 1 ), ACK_CHECK_EN); //phase 1, write operation
    // send register we want
    i2c_master_write_byte(cmd, i2c_reg, ACK_CHECK_EN); //enable checking for slave's acjnowledge
    // Send repeated start
    i2c_master_start(cmd); //generate repeated start condition
    // now send device address (indicating read) & read data
    i2c_master_write_byte(cmd, ( i2c_addr << 1 ) | READ_BIT, ACK_CHECK_EN); //phase 2 is the read operation
    if (size > 1) { //if reading multiple bytes, read all but the last byte 
        i2c_master_read(cmd, data_rd, size - 1, ACK_VAL); //reading all but the last byte
    }
    i2c_master_read_byte(cmd, data_rd + size - 1, NACK_VAL); //read the final byte with the nack
    i2c_master_stop(cmd); //release the I2C bus
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS); execute the I2C commands
    i2c_cmd_link_delete(cmd); //free the resources used by the command link
    return ret; //return the status if the I2C operation
}

/**
 * @brief Test code to write i2c slave device with registered interface
 *        Master device write data to slave(both esp32),
 *        the data will be stored in slave buffer.
 *        We can read them out from slave buffer.
 * ____________________________________________________________________________________
 * | start | slave_addr + wr_bit + ack | register + ack | write n bytes + ack  | stop |
 * --------|---------------------------|----------------|----------------------|------|
 *
 */
static esp_err_t i2c_master_write_slave_reg(i2c_port_t i2c_num, uint8_t i2c_addr, uint8_t i2c_reg, uint8_t* data_wr, size_t size) { // Function to write data to a slave device's register over I2C
    i2c_cmd_handle_t cmd = i2c_cmd_link_create(); // Create a new I2C command link (a sequence of I2C operations)
    i2c_master_start(cmd); // Generate START condition on I2C bus (beginning of transaction)

    // Log the write operation details
    ESP_LOGI(TAG, "Writing to I2C device: 0x%02X", i2c_addr); // - Device address being written to
    ESP_LOGI(TAG, "Register address: 0x%02X", i2c_reg); // - Register address being written
    ESP_LOGI(TAG, "Data to write: 0x%02X", *data_wr); // - First byte of data being written (helpful for debugging)

    // Send device address + write bit
    i2c_master_write_byte(cmd, (i2c_addr << 1) | I2C_MASTER_WRITE, ACK_CHECK_EN);  // ACK_CHECK_EN enables checking for slave's acknowledge

    
    i2c_master_write_byte(cmd, i2c_reg, ACK_CHECK_EN); // Send register address

    
    i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN); // Write the data

    i2c_master_stop(cmd); // Generate STOP condition (ends the transaction and releases the bus)

    // Execute the I2C command
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS); // Execute the I2C commands with a timeout of 1000ms
    if (ret != ESP_OK) { // Error handling: Log if the operation failed
        ESP_LOGE(TAG, "I2C write failed: %s", esp_err_to_name(ret)); //output
    } else { //or
        ESP_LOGI(TAG, "I2C write successful"); //good communication
    }

    i2c_cmd_link_delete(cmd); // Free the resources used by the command link
    return ret; // Return the status of the I2C operation (ESP_OK on success)
}

/* Read contents of a register
---------------------------------------------------------------------------*/
esp_err_t rdAFE( uint8_t reg, uint8_t *pdata, uint8_t count ) //setting up variables to read in the register
{
	return( i2c_master_read_slave_reg(I2C_PORT_NUM, BQ7692003PWR_I2C_ADDR,  reg, pdata, count ) ); //returning what is read
}

/* Write value to specified register
---------------------------------------------------------------------------*/
esp_err_t wrAFE( uint8_t reg, uint8_t *pdata, uint8_t count ) //setting up variables to write in the register
{
	return( i2c_master_write_slave_reg( I2C_PORT_NUM, BQ7692003PWR_I2C_ADDR,  reg, pdata, count ) ); //returning what is read
}


void wake_up_bq76920() { // Function to wake up the BQ76920 battery monitor IC by sending a pulse on TS1 pin
    gpio_set_direction(TS1_GPIO, GPIO_MODE_OUTPUT);  // Configure the TS1 GPIO pin as an output

    // Ensure TS1 is LOW initially
    gpio_set_level(TS1_GPIO, 0); // Set TS1 pin to LOW (logic level 0) to establish initial state
    vTaskDelay(pdMS_TO_TICKS(50));  // Wait 50ms

    // Create a rising edge by setting TS1 HIGH
    gpio_set_level(TS1_GPIO, 1); // Maintain HIGH state for 50 milliseconds (pulse width)
    vTaskDelay(pdMS_TO_TICKS(50));  // Wait 50ms

    ESP_LOGI("BQ76920", "Wake-up pulse sent to TS1");  // Log successful wake-up pulse transmission
}

void test_write_and_verify() { // Function to test writing to and reading back from a register (CC_CFG) to verify proper I2C communication
    uint8_t data_to_write = 0x19;  // Example data to write
    uint8_t read_data = 0; // Buffer to store read-back data (initialized to 0 for safety)

    // Write to CC_CFG
    esp_err_t err = wrAFE(CC_CFG, &data_to_write, 1); // Write the test data to CC_CFG register using wrAFE function
    if (err != ESP_OK) { // Check if write operation failed
        ESP_LOGE(TAG, "Failed to write to CC_CFG: %s", esp_err_to_name(err)); // Log error with details if write failed
        return; // Exit function early on failure
    }

    // Read back from CC_CFG
    err = rdAFE(CC_CFG, &read_data, 1); / Read back from the same CC_CFG register using rdAFE function
    if (err != ESP_OK) { // Check if read operation failed
        ESP_LOGE(TAG, "Failed to read from CC_CFG: %s", esp_err_to_name(err)); // Log error with details if read failed
        return; // Exit function early on failure
    }

    // Verify the written value
    if (read_data == data_to_write) { // Compare read-back value with originally written value
        ESP_LOGI(TAG, "Write verified successfully. CC_CFG value: 0x%02X", read_data); // Success case - log the verified value
    } else { //or 
        ESP_LOGE(TAG, "Write verification failed. Expected: 0x%02X, Actual: 0x%02X", data_to_write, read_data); // Failure case - log both expected and actual values
    }
}

void set_bit(uint8_t reg, uint8_t bit) { //function to set a specific bit in an 8-bit register
    if (bit > 7) { // check id the bit position is valid 
        ESP_LOGE(TAG, "Invalid bit position. Bit must be between 0 and 7."); // log an error if the bit position is invalid
        return; // return the error
    }

    uint8_t reg_value; // to store the current register value
    esp_err_t err; // to store error codes from register operations

    // Step 1: Read the current value of the register
    err = rdAFE(reg, &reg_value, 1); // we are reading 1 byte
    if (err != ESP_OK) { // check if the read operation failed
        ESP_LOGE(TAG, "Failed to read register 0x%02X: %s", reg, esp_err_to_name(err)); //log an error with the register address and error description
        return; // exit the function if read failed
    }
    ESP_LOGI(TAG, "Current register 0x%02X value: 0x%02X", reg, reg_value); // log the current register value for debugging

    // Step 2: Set the specified bit to 1
    reg_value |= (1 << bit);  // Set the bit at the specified position

    // Step 3: Write the modified value back to the register
    err = wrAFE(reg, &reg_value, 1); // wrAFE writes the new value back to the register 
    if (err != ESP_OK) { // check if the write operation failed
        ESP_LOGE(TAG, "Failed to write register 0x%02X: %s", reg, esp_err_to_name(err)); //log an error with the regsiter
        return; // exit the function
    }
    ESP_LOGI(TAG, "Bit %d set. New register 0x%02X value: 0x%02X", bit, reg, reg_value); //log success message showing which bit was set 
}


/**
 * @brief Read the value of a specified register.
 * @param reg The register address (e.g., SYS_STAT, SYS_CTRL1, etc.).
 * @return The value of the register, or 0xFF if the read operation fails.
 */
uint8_t read_register(uint8_t reg) { // function to read the value form an 8-bit register
    uint8_t reg_value = 0xFF;  // Default value in case of read failure
    esp_err_t err; // variable to store error codes from register operations

    // Step 1: Read the current value of the register
    err = rdAFE(reg, &reg_value, 1); //the '1' parameter likely indicates we're reading 1 byte
    if (err != ESP_OK) { //check if the read operation failed
        ESP_LOGE(TAG, "Failed to read register 0x%02X: %s", reg, esp_err_to_name(err)); //log an error
    }
    /*else {
        // Log the register address and its value in hex format
        ESP_LOGI(TAG, "Read register 0x%02X: 0x%02X", reg, reg_value);
    }*/
    return reg_value; // return the register value
    vTaskDelay(pdMS_TO_TICKS(500)); // set some delay
}

// Function to read the cell voltage
float read_cell_voltage(uint8_t vc_hi_addr, uint8_t vc_low_addr) { // combines two 8-bit registers
    // Read the values of VC_HI and VC_LOW registers
    uint8_t vc_hi = read_register(vc_hi_addr); // read the high byte from the address
    uint8_t vc_low = read_register(vc_low_addr); // read the low byte from the register address
    printf("This is the HI: 0x%02X, and this is the Lo: 0x%02X \n", vc_hi, vc_low); // for debugging

    // Combine VC_HI and VC_LOW into a 16-bit value
    uint16_t combined_value = (vc_hi << 8) | vc_low; // shift the high byte left by 8 bits

    // Mask out bits <15:14> to use only bits <13:0>
    combined_value = combined_value & 0x3FFF; // 0x3FFF = 0b0011111111111111

    // Multiply the combined value by 375 microvolts (375e-6 volts)
    float voltage = combined_value * 375e-6; //multiply to get the actual voltage

    return voltage; // computed voltage
}
// Function to read the cell voltage
float read_bat_voltage(uint8_t vc_hi_addr, uint8_t vc_low_addr) { // rad battery voltage
    // Read the values of VC_HI and VC_LOW registers
    uint8_t vc_hi = read_register(vc_hi_addr); //read the high byte
    uint8_t vc_low = read_register(vc_low_addr); // read the low byte
    printf("This is the HI: 0x%02X, and this is the Lo: 0x%02X \n", vc_hi, vc_low); // for debugging

    // Combine VC_HI and VC_LOW into a 16-bit value
    uint16_t combined_value = (vc_hi << 8) | vc_low; //shift the high byte left

    // Multiply the combined value by 375 microvolts (375e-6 volts)
    float voltage = combined_value * 375e-6; // computing the voltage

    return voltage; // return the computed voltage
}

static void afe_init() // reads and prints the system status register
{ 

    printf("This is sys_STAT:  0x%02X \n", read_register(SYS_STAT)); // debugging: display the register value
    float voltage = read_cell_voltage(VC1_HI, VC1_LO); // read cell 1 voltage 
    printf("Cell 1 Voltage: %f V\n", voltage); // for debugging
    printf("This is battery Voltage: %f V \n", read_bat_voltage(BAT_HI, BAT_LO)); // read and print out the battery voltage
    
}

void i2c_init() { // sets up the I2C in master mode
    i2c_config_t conf = {0}; // configure the I2C in master mode
    conf.mode = I2C_MODE_MASTER; // set as I2C master
    conf.sda_io_num = I2C_SDA_IO; //SDA pin
    conf.sda_pullup_en = GPIO_PULLUP_ENABLE; //enable the internal pull-up
    conf.scl_io_num = I2C_SCL_IO; //SCL pin
    conf.scl_pullup_en = GPIO_PULLUP_ENABLE; //enable the internal pull-up
    conf.master.clk_speed = I2C_FREQ_HZ; // set I2C clock speed
    
    esp_err_t err = i2c_param_config(I2C_PORT_NUM, &conf); // apply the I2C configuration
    if (err != ESP_OK) { // checking if there is an error
        ESP_LOGE("I2C", "i2c_param_config failed: %s", esp_err_to_name(err)); // print code
        return; // reuturn the error message
    }

    err = i2c_driver_install(I2C_PORT_NUM, I2C_MODE_MASTER, 0, 0, 0); //install I2C driver
    if (err != ESP_OK) { // checking if there is an error
        ESP_LOGE("I2C", "i2c_driver_install failed: %s", esp_err_to_name(err)); // print out message if bad
    } else {
        ESP_LOGI("I2C", "I2C initialized successfully!");//print out message if good
    }
}

void i2c_scanner() { // scans all I2C addresses 
    ESP_LOGI(TAG, "Scanning I2C bus..."); // print out message
    for (uint8_t addr = 0x01; addr < 0x7F; addr++) { //loop through possible I2C addresses
        i2c_cmd_handle_t cmd = i2c_cmd_link_create(); //handle function
        i2c_master_start(cmd); // send start condition
        i2c_master_write_byte(cmd, (addr << 1) | WRITE_BIT, ACK_CHECK_EN); // send address and write bit
        i2c_master_stop(cmd); // send stop command
        esp_err_t ret = i2c_master_cmd_begin(I2C_PORT_NUM, cmd, 1000 / portTICK_PERIOD_MS); // execute the command and check fro acknowledgment
        i2c_cmd_link_delete(cmd); // free command handle
        if (ret == ESP_OK) { // if device responds 
            ESP_LOGI(TAG, "Found device at address: 0x%02X", addr); // logs the address
        }
    }
    ESP_LOGI(TAG, "Scan complete."); // setup complete
}


// Sine wave lookup table
uint8_t sineTable[SINE_RESOLUTION]; //precomputed sine wave for DAC output

// Morse code lookup table
const char *morseCode[37] = { //Morse representations
    ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--..", // A-Z
    "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----.", // 0-9
    ".-.-.-" // .
};

// Generate sine wave lookup table
void generateSineTable() { //function definition
    for (int i = 0; i < SINE_RESOLUTION; i++) { //does through the sine wave
        sineTable[i] = (uint8_t)(127.5 + 127.5 * sin(2 * M_PI * i / SINE_RESOLUTION)); // computes the 256-point sine wave
    }
}

// Initialize DAC
void dac_init() { // function definition
    dac_output_enable(DAC_PIN); // Enable DAC channel
}

// Output a value to the DAC
void dac_output(uint8_t value) { // function definition
    dac_output_voltage(DAC_PIN, value); // Set DAC output voltage (0-255)
}

// Initialize LED
void led_init() { // function definitino 
    gpio_reset_pin(LED_PIN); // Reset the LED pin
    gpio_set_direction(LED_PIN, GPIO_MODE_OUTPUT); // Set LED pin as output
}

// Initialize transistor pin
void trans_init() { // function definiition
    gpio_reset_pin(Trans); // Reset the LED pin
    gpio_set_direction(Trans, GPIO_MODE_OUTPUT); // Set LED pin as output
}

// Play a Morse code symbol (dot or dash)
void playMorseSymbol(const char symbol, int frequency) {
    int duration = (symbol == '.') ? DOT_DURATION : DASH_DURATION;
    int delayTime = 1000000 / (frequency * SINE_RESOLUTION); // Microseconds per step

    // Turn on LED and play sine wave for the duration of the symbol
    gpio_set_level(LED_PIN, 1); // Set LED pin high
    for (int t = 0; t < duration; t += delayTime) {
        for (int i = 0; i < SINE_RESOLUTION; i++) {
            dac_output(sineTable[i]); // Output sine wave
            vTaskDelay(pdMS_TO_TICKS(delayTime / 1000)); // Delay for frequency control
        }
    }
    gpio_set_level(LED_PIN, 0); // Set LED pin low

    // Silence for the space between parts of the same letter
    vTaskDelay(pdMS_TO_TICKS(PART_SPACE_DURATION));
}

// Play a Morse code letter
void playMorseLetter(const char *code, char letter, int frequency) {
    // Print the letter and its Morse code
    printf("Letter: %c, Morse Code: %s\n", letter, code);

    while (*code) {
        //printf("%c ", *code); // Print each Morse symbol (dot or dash)
        playMorseSymbol(*code, frequency);
        code++;
    }
    
}

// Play a Morse code string
void playMorseString(const char *text, int frequency) {
    while (*text) {
        if (*text == ' ') {
            // Space between words
            printf("  (Word Space)\n");
            vTaskDelay(pdMS_TO_TICKS(WORD_SPACE_DURATION));
        } else {
            // Get Morse code for the character
            int index = (*text >= 'A' && *text <= 'Z') ? *text - 'A' :
                        (*text >= 'a' && *text <= 'z') ? *text - 'a' :
                        (*text >= '0' && *text <= '9') ? *text - '0' + 26:
                        (*text == '.') ? 36 :
                        -1;
            if (index >= 0) {
                playMorseLetter(morseCode[index], *text, frequency);
                // Space between letters
                vTaskDelay(pdMS_TO_TICKS(LETTER_SPACE_DURATION));
            }
        }
        text++;
    }
}


// Flag variable to store detected action number
volatile int bit_action_flag = -1;

// Hold previous value of the Bit flag
volatile int bit_prev_flag = -1;

// Monitor Bits of gpio pins and determine if the reading is accurate and set a flag for trigger
void vTaskMonitorBits(void *pvParameters) {
    // Internal count variable for the number of times read the same value
    int count = 1;

    // Decimal Value to represent the value of the bits in decimal
    int decimal_value = 0;

    // Variable responsible for holding the last value of the decimal value
    int prev_decimal_value = -1;

    // Infinte while to loop till an action flag is triggered
    while (1) {

        // Initial if statement to check if the bit_action_flag is in its orgrinal state -1
        if(bit_action_flag == -1){

            //reset the decimal value to zero at begining of every loop
            decimal_value = 0;

            // Read the state of each GPIO pin and calculate the decimal value
            for (int i = 0; i < NUM_PINS; i++) {
                int state = gpio_get_level(pins[i]);
                decimal_value |= (state << i);  // Combine the bits to form the binary number
            }

            // Print the binary and decimal values
            printf("Binary: %d%d%d%d, Decimal: %d\n",
               gpio_get_level(pins[3]),  // MSB (Bit3)
               gpio_get_level(pins[2]),  // Bit2
               gpio_get_level(pins[1]),  // Bit1
               gpio_get_level(pins[0]),  // LSB (Bit0)
               decimal_value);
            
            // Check if the current value matches the previous value
            if (decimal_value == prev_decimal_value) {
                count++; // Increment the counter
            } 
            // Else reset the count to 1
            else {
                count = 1; // Reset the counter if the value changes
            }

            // Update the previous value
            prev_decimal_value = decimal_value;

            // if condition that checks to see if bit_action_flag needs to be set 
            // checks if the previous flag is not the same as current, dont do action on zero, and make sure there was a count of 3
            if(bit_prev_flag != decimal_value && decimal_value !=0 && (count >=3)){
                // set bit flag to the new decimal value
                bit_action_flag = decimal_value;
            }
            // Delay before next reading
            vTaskDelay(pdMS_TO_TICKS(5000));
        }
        else{
            // Suspend task if a flag is triggered
            vTaskSuspend(NULL);
        } 
    } 
}

// Initialize transistor pin
void bit_init() {
    // Configure the GPIO pins as inputs
    gpio_config_t io_conf;
    io_conf.intr_type = GPIO_INTR_DISABLE;  // Disable interrupt
    io_conf.mode = GPIO_MODE_INPUT;         // Set as input mode
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;  // Disable pull-down
    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;      // Disable pull-up

    for (int i = 0; i < NUM_PINS; i++) {
        io_conf.pin_bit_mask = (1ULL << pins[i]);
        gpio_config(&io_conf);
    }
}

//Define variable for 
TaskHandle_t xTaskBitMonitor = NULL; // Declare a variable to store the task handle



void every_int(){
    /*
    vTaskDelay(pdMS_TO_TICKS(500));
    i2c_init();
    vTaskDelay(pdMS_TO_TICKS(500));
    wake_up_bq76920();
    vTaskDelay(pdMS_TO_TICKS(500));
    i2c_scanner();
    vTaskDelay(pdMS_TO_TICKS(500));
    
    //printf("This is working");
    
    afe_init();
    
      
    */

    // Initialize DAC
    dac_init(); 

    // Initialize LED
    led_init();

    // Intialize PTT transistor gpio
    trans_init();

    //Intialize gpio bits 0-3 
    bit_init();

    // Generate sine wave lookup table
    generateSineTable();

    
}

#define UART_NUM        UART_NUM_1  // Use UART1 for MAVLink
#define TX_PIN          17
#define RX_PIN          16
#define BAUD_RATE       57600
#define MAV_SYSTEM_ID   1   // Pixhawk system ID
#define ESP_SYSTEM_ID   255 // ESP32 system ID
#define MAV_COMP_ID     0   // Target component (autopilot)

// Debugging tag
static const char *TAGG = "MAVLINK_ESP32";

// Function to initialize UART for MAVLink
void init_uart() {
    uart_config_t uart_config = {
        .baud_rate = BAUD_RATE,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_DEFAULT
    };

    uart_driver_install(UART_NUM, 512, 0, 0, NULL, 0);
    uart_param_config(UART_NUM, &uart_config);
    uart_set_pin(UART_NUM, TX_PIN, RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);

    ESP_LOGI(TAGG, "UART initialized for MAVLink");
}

// Function to send an ARM/DISARM command to Pixhawk
void send_arm_disarm(bool arm) {
    mavlink_message_t msg;
    uint8_t buf[MAVLINK_MAX_PACKET_LEN];

    mavlink_msg_command_long_pack(
        ESP_SYSTEM_ID, MAV_COMP_ID, &msg,
        MAV_SYSTEM_ID, MAV_COMP_ID,
        MAV_CMD_COMPONENT_ARM_DISARM, // MAVLink command to ARM/DISARM
        0,  // Confirmation
        arm ? 1 : 0,  // Param1: 1 to arm, 0 to disarm
        0, 0, 0, 0, 0, 0  // Unused parameters
    );

    uint16_t len = mavlink_msg_to_send_buffer(buf, &msg);
    uart_write_bytes(UART_NUM, buf, len);
    
    ESP_LOGI(TAGG, "Sent MAVLink %s command", arm ? "ARM" : "DISARM");
}


void request_mavlink_data() {
    mavlink_message_t msg;
    uint8_t buf[MAVLINK_MAX_PACKET_LEN];

    mavlink_msg_command_long_pack(
        255, 0, &msg,   // ESP32 as sender
        1, 0,           // Pixhawk system ID and component ID
        MAV_CMD_SET_MESSAGE_INTERVAL, 
        0, 
        MAVLINK_MSG_ID_GLOBAL_POSITION_INT, // Request GPS data
        100000,  // Send every 100ms (10Hz)
        0, 0, 0, 0, 0  // Unused
    );

    uint16_t len = mavlink_msg_to_send_buffer(buf, &msg);
    uart_write_bytes(UART_NUM, buf, len);
    
    ESP_LOGI("MAVLINK", "Requested MAVLink GPS Data from Pixhawk");
}


// Function to process received MAVLink messages
void process_mavlink_message(mavlink_message_t *msg) {
    if (msg->msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {
        mavlink_global_position_int_t gps;
        mavlink_msg_global_position_int_decode(msg, &gps);

        // Convert latitude & longitude from 1E7 format to decimal degrees
        float lat = gps.lat / 1e7;
        float lon = gps.lon / 1e7;
        float alt = gps.alt / 1000.0;  // Convert mm to meters

        ESP_LOGI(TAGG, "GPS: Lat: %.7f, Lon: %.7f, Alt: %.2f m", lat, lon, alt);
    }
    else {
        ESP_LOGW(TAGG, "MAVLink message received, but not GPS data (ID: %d)", msg->msgid);
    }
}

// Task to receive and parse MAVLink messages
void receive_mavlink_task(void *pvParameters) {
    uint8_t data;
    mavlink_message_t msg;
    mavlink_status_t status;
    ESP_LOGI(TAGG, "GPS initialized for MAVLink: begin parsing");

    while (1) {

        int len = uart_read_bytes(UART_NUM, &data, 1, 100 / portTICK_PERIOD_MS);
        if (len > 0) {
            if (mavlink_parse_char(MAVLINK_COMM_0, data, &msg, &status)) {
                process_mavlink_message(&msg);
                ESP_LOGI(TAG, "Received MAVLink Message ID: %d", msg.msgid);
            }
        }
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
// Responsible for determing what each digit does and how to react
void num_actions(int num_val){
    //char message[20];  // Adjust the size as needed

    //Enable push to talk
    gpio_set_level(Trans, 1);
    vTaskDelay(pdMS_TO_TICKS(1000));        //Pause for time     

    // If else block for each of the digits
    if(bit_action_flag == 1){      
        // playMorseString("One", FREQUENCY); 
        send_arm_disarm(true);  // ARM the Pixhawk

        /*
        printf("Executing Action %d, reading Cell1 Voltage \n", bit_action_flag);
        // Read the voltage of Cell 1
        float voltage = read_cell_voltage(VC1_HI, VC1_LO);
        // Convert the voltage value to a string
        snprintf(message, sizeof(message), "%.2f", voltage);

        // Log the voltage value for debugging
        printf("Cell 1 Voltage: %s V\n", message);
            
        // Play Morse code message
        playMorseString(message, FREQUENCY);
        */   
    }
    else if(bit_action_flag == 2){      
        // playMorseString("Two", FREQUENCY);  
        send_arm_disarm(false);  // ARM the Pixhawk
  
    }
    else if(bit_action_flag == 3){      
        playMorseString("Three", FREQUENCY);    
    }
    else if(bit_action_flag == 4){      
        playMorseString("Four", FREQUENCY);    
    }
    else if(bit_action_flag == 5){      
        playMorseString("Five", FREQUENCY);    
    }
    else if(bit_action_flag == 6){      
        playMorseString("Six", FREQUENCY);    
    }
    else if(bit_action_flag == 7){      
        playMorseString("Seven", FREQUENCY);    
    }
    else if(bit_action_flag == 8){      
        playMorseString("Eight", FREQUENCY);    
    }
    else if(bit_action_flag == 9){      
        playMorseString("Nine", FREQUENCY);    
    }
    else{
        printf("Not an actionable task \n");
        bit_action_flag = 0;
    }

    // Wait time
    vTaskDelay(pdMS_TO_TICKS(1000));

    // Disable PTT gpio
    gpio_set_level(Trans, 0);

    // Wait time
    vTaskDelay(pdMS_TO_TICKS(1000));

    // Store value of action flag in a previous flag 
    bit_prev_flag = bit_action_flag;

    // Reset the bit action flag
    bit_action_flag = -1;
        
    // Resume the TaskBitMonitor 
    vTaskResume(xTaskBitMonitor);
}

void app_main() {
    // Intialize everything we need
    every_int();
    init_uart();

    //Create task to monitor bits, defined xTaskBitMonitor
    xTaskCreate(vTaskMonitorBits, "Bit Monitor Task", 2048, NULL, 5, &xTaskBitMonitor);
    
    while (1) {

        // Checks if bit action is needed
        if(bit_action_flag != -1){
            num_actions(bit_action_flag);
        }

        // Delay between each reading of the bit action flag
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
    

}
