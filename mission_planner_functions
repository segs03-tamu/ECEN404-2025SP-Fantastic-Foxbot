#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/uart.h"
#include "mavlink/common/mavlink.h"
#include "esp_log.h"

// UART Configuration
#define UART_NUM UART_NUM_2
#define UART_TX_PIN 17
#define UART_RX_PIN 16

// MAVLink System and Component IDs
#define ESP_SYSTEM_ID 2              // System ID for ESP32
#define MAV_COMP_ID 1                // Component ID for ESP32
#define MAV_SYSTEM_ID 1              // PixHawk system ID
#define MAV_AUTOPILOT_COMP_ID 1      // PixHawk autopilot component ID

// Mode definitions
#define MANUAL_MODE 0
#define AUTO_MODE 10

static const char *TAGG = "ESP32_MAVLINK";

void init_uart(void) {
    uart_config_t uart_config = {
        .baud_rate = 57600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };
    uart_param_config(UART_NUM, &uart_config);
    uart_set_pin(UART_NUM, UART_TX_PIN, UART_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    uart_driver_install(UART_NUM, 1024, 0, 0, NULL, 0);
    
    ESP_LOGI(TAGG, "UART initialized");
}

void send_heartbeat(void) {
    mavlink_message_t msg;
    uint8_t buf[MAVLINK_MAX_PACKET_LEN];
    
    mavlink_msg_heartbeat_pack(
        ESP_SYSTEM_ID,                // System ID
        MAV_COMP_ID,                  // Component ID
        &msg,
        MAV_TYPE_GCS,                 // Type: Ground Control Station
        MAV_AUTOPILOT_INVALID,        // Autopilot: Not applicable for GCS
        MAV_MODE_FLAG_CUSTOM_MODE_ENABLED, // Base mode: Custom mode enabled
        0,                            // Custom mode: 0 for GCS
        MAV_STATE_ACTIVE              // System state: Active
    );
    
    uint16_t len = mavlink_msg_to_send_buffer(buf, &msg);
    uart_write_bytes(UART_NUM, buf, len);
    
    ESP_LOGD(TAGG, "Sent MAVLink heartbeat");
}

void heartbeat_task(void *pvParameters) {
    while (1) {
        send_heartbeat();
        vTaskDelay(1000 / portTICK_PERIOD_MS); // Send heartbeat every 1 second
    }
}

void receive_heartbeat(const mavlink_heartbeat_t *heartbeat) {
    uint32_t now = xTaskGetTickCount() * portTICK_PERIOD_MS;
    bool was_connected = pixhawk_connected;
    
    // Update connection status
    pixhawk_connected = true;
    last_pixhawk_heartbeat = now;
    
    // Log connection establishment
    if (!was_connected) {
        ESP_LOGI(TAGG, "PIXHAWK CONNECTION ESTABLISHED");
    }
    
    // Display heartbeat information every 15 second
    static uint32_t last_heartbeat_display = 0;
    if (now - last_heartbeat_display > 15000) {

        ESP_LOGI(TAGG, "Mode: %s", get_mode_string(heartbeat->custom_mode));
        ESP_LOGI(TAGG, "Status: %s", get_system_status_string(heartbeat->system_status));
        ESP_LOGI(TAGG, "Type: %d, Autopilot: %d", heartbeat->type, heartbeat->autopilot);
        ESP_LOGI(TAGG, "Base Mode: 0x%02X", heartbeat->base_mode);
        
        last_heartbeat_display = now;
    }
}

void send_command_long(uint16_t command, float param1, float param2, float param3, 
                       float param4, float param5, float param6, float param7) {
    mavlink_message_t msg;
    uint8_t buf[MAVLINK_MAX_PACKET_LEN];
    
    mavlink_msg_command_long_pack(
        ESP_SYSTEM_ID, MAV_COMP_ID, &msg,
        MAV_SYSTEM_ID, MAV_AUTOPILOT_COMP_ID,
        command,
        0,  // Confirmation
        param1, param2, param3, param4, param5, param6, param7
    );
    
    uint16_t len = mavlink_msg_to_send_buffer(buf, &msg);
    uart_write_bytes(UART_NUM, buf, len);
    
    ESP_LOGI(TAGG, "Sent MAVLink command %d", command);
}


void send_arm_disarm(bool arm) {
    mavlink_message_t msg;
    uint8_t buf[MAVLINK_MAX_PACKET_LEN];
    mavlink_msg_command_long_pack(
        ESP_SYSTEM_ID, MAV_COMP_ID, &msg,
        MAV_SYSTEM_ID, MAV_AUTOPILOT_COMP_ID,
        MAV_CMD_COMPONENT_ARM_DISARM, // MAVLink command to ARM/DISARM
        0,  // Confirmation
        arm ? 1 : 0,  // Param1: 1 to arm, 0 to disarm
        0, 0, 0, 0, 0, 0  // Unused parameters
    );
    uint16_t len = mavlink_msg_to_send_buffer(buf, &msg);
    uart_write_bytes(UART_NUM, buf, len);
    
    ESP_LOGI(TAGG, "Sent MAVLink %s command", arm ? "ARM" : "DISARM");
}


// Set the vehicle to autopilot/auto mode
void set_auto_mode(void) {
    send_command_long(
        MAV_CMD_DO_SET_MODE,
        MAV_MODE_FLAG_CUSTOM_MODE_ENABLED,  // Enable custom mode (param1)
        AUTO_MODE,                          // Auto mode (param2)
        0, 0, 0, 0, 0                       // Unused parameters
    );
    
    ESP_LOGI(TAGG, "Set AUTO mode");
}


// Set the vehicle to manual mode
void set_manual_mode(void) {
    send_command_long(
        MAV_CMD_DO_SET_MODE,
        MAV_MODE_FLAG_CUSTOM_MODE_ENABLED,  // Enable custom mode (param1)
        MANUAL_MODE,                        // Manual mode (param2)
        0, 0, 0, 0, 0                       // Unused parameters
    );
    
    ESP_LOGI(TAGG, "Set MANUAL mode");
}


// Start mission execution
void start_mission(void) {
    send_command_long(
        MAV_CMD_MISSION_START,
        0, 0, 0, 0, 0, 0, 0               // All params unused for this command
    );
    
    ESP_LOGI(TAGG, "Started mission");
}
